
#### excitation

excitationSimulate: 1        #simulate torques instead of using measurements to save to data files (use e.g. with Gazebo)
exciteMethod: null #'yarp'         #currently 'yarp', 'ros' or null
useDeg: 1                    #encode angles in degrees for excitation (internal and data is always in rad)

optimizeTrajectory: 0        #find new parameters with optimization or load previous params from file (if no file exists, use random)
showOptimizationGraph: 1     #display updating graph during trajectory optimization
showOptimizationTrajs: 1     #display the trajectory plot after each optimization step
useGlobalOptimization: 1     #do global optimization before using local refinement (does not use initial values)
globalOptIterations: 10
localOptIterations: 2        #how many optimizer iterations to use. this is not necessarily equal to function calls (~50 times of this)
maxFun: 250                  #limit objective function evaluations to this value (not used currently)
minTolConstr: 0.01         #threshold for being within constraints (only used for display)

# initial values to start optimization from (if using global opt not really important)
trajectoryPulseInit: 0.75    #determines length of one period of trajectory (smaller=longer)
trajectoryPulseMin:  0.5
trajectoryPulseMax:  1.0
trajectoryCoeffInit: 0.1     #set this as high as possible without violating velocity constraints (see output after start)
trajectoryCoeffMin: -0.4     #determines in which range the chosen params have to be (smaller=lower vel)
trajectoryCoeffMax:  0.4
trajectoryAngleMin: -10.0    #determines the range in which the pulsation center for each joint will be (in degrees)
trajectoryAngleMax: 10.0

# instead of one range, define individual ranges for each link. initial is the center of these
# ranges. If ..AngleMin/Max is to be used for all of them, set to null
trajectoryAngleRanges:
    [[-10.9745248069, 8.9797344371],
     [-18.9543738355, 8.9746393985],
     [-27.938974128, 13.9696016556],
     [10.0,          30.929013234],
     [-12.9596980573, 5.9797344371],
     [-8.9771869178, 8.9771869178]
    ]
#    [[-49.9745248069, 39.9797344371],
#     [-89.9543738355, 49.9746393985],
#     [-119.938974128, 59.9696016556],
#     [0.0,            139.929013234],
#     [-79.9596980573, 39.9797344371],
#     [-44.9771869178, 44.9771869178]
#    ]

# manual angle limits: pairs of upper and lower (in degrees). put in null to use values from URDF
# (or leave completely empty)
ovrPosLimit:
    - null
    - null 
    - null
    - null
    - null
    - null
    - null

# constrain to minimal velocity (percentage of maximum) for each joint (better excitation of parameters)
minVelocityConstraint: 0
minVelocityPercentage: 0.1

#### data processing and selection

# determine number of samples to use
# (Khalil recommends about 500 times number of parameters to identify)
startOffset: 650    #how many samples from the beginning of each measurement file are skipped
skipSamples: 5    #how many values to skip before using the next sample

# whether only "good" data is being selected or simply all is used (selected by condition number)
selectBlocksFromMeasurements: 0
blockSize: 50  # needs to be at least as much as parameters so regressor is square or higher
selectBestPerenctage: 70   #select percentage of blocks sorted by condition number

removeNearZero: 0   #remove samples that have almost zero velocity (could be better for friction estimation)
minVel: 0.01        #velocity that one of a sample's joints needs to have for the sample to be used (rad/s)

# IMU processing (floating base)
waitForZeroAcc: 1   #when integrating IMU linear acceleration, wait for first time with (almost) no acceleration to start at zero velocity
zeroAccThresh: 0.4  #threshold below which acceleration is considered to be zero (m/s^2)

#### identification

# fixed or floating-base dynamics
floatingBase: 1
baseLinkName: 'Waist'

# identify torque offsets as additional parameters
identifyTorqueOffsets: 1

# identify motor friction
identifyFriction: 1

# simulate torques from target values, don't use both
simulateTorques: 0    #simulate torque for measured angles etc using idyntree (instead of reading from data)
addNoise: 0 #0.05  #additional percentage of zero-mean white noise for simulated or measured torques

# almost zero threshold for QR, SVD and other things
minTol: 0.001

## constrained SDP to solve OLS

# constrain std params to physical consistent space to only achieve physical consistent parameters
# (currently this also does the estimation, so previously selecting another method has no effect)
# if only torque estimation is desired, not using this self.option might give a better model
# accuracy with approriate parameters
useConsistencyConstraints: 0

# identify in two steps: first get feasible base parameters, then minimize distance to CAD while
# finding feasible standard parameters
identifyClosestToCAD: 0

limitNonIdentifiable: 0

# constrain parameters for links more than a certain condition number to the a priori values
# (to prevent very big changes for parameters that are not expressed in the data)
noChange: 1
noChangeThresh: 300

# restrict COM to smallest enclosing box of STL Mesh (taken from <visual> in URDF)
restrictCOMtoHull: 0
# set extra scaling for mesh (e.g. if it is clear that COM will not be at outer border of
# geometry or that initial CAD data is too large)
hullScaling: 1.0
# name of the directory after the package base name (as in package://basename/)
meshBaseDir: 'meshes'
# fallback cube size (in case mesh file is not found, a cube with the old value in the center is used)
cubeSize: 1.0

# constrain overall mass
limitOverallMass: 1
# if overall mass is set, constrain mass close to this value. If null, limit to overall a priori mass +- 30%
limitMassVal: 139.15

# enforce staying around the a priori masses (only set this or a combination of the other
# two mass limiting self.options to prevent constraint conflicts!)
limitMassToApriori: 0
limitMassAprioriBoundary: 0.01     #allowed change of CAD value in both +- directions (1.0 = 100%)

# specify single params that will be constrained to the CAD values
dontChangeParams: []

# define constraints for link symmetries (e.g. left and right arm)
useSymmetryConstraints: 0
# allow some difference between symmetry pairs (1.0 = 100%)
symmetryTolerance: 0.05
# tuples of two parameter ids each that should be equal and 1/-1 to allow negative symmetric, e.g.
# [p1, p2, sign]
symmetryConstraints:
    - [160,280, 1]  #'L/RShp'
    - [161,281, 1]
    - [162,282, -1]
    - [163,283, 1]
    - [164,284, 1]
    - [165,285, -1]
    - [166,286, 1]
    - [167,287, 1]
    - [168,288, -1]
    - [169,289, 1]
    - [170,290, 1]  #'L/RShr'
    - [171,291, 1]
    - [172,292, -1]
    - [173,293, 1]
    - [174,294, 1]
    - [175,295, -1]
    - [176,296, 1]
    - [177,297, 1]
    - [178,298, -1]
    - [179,299, 1]
    - [180,300, 1]  #'L/RShy'
    - [181,301, 1]
    - [182,302, -1]
    - [183,303, 1]
    - [184,304, 1]
    - [185,305, -1]
    - [186,306, 1]
    - [187,307, 1]
    - [188,308, -1]
    - [189,309, 1]
    - [190,310, 1]  #'L/RElb'
    - [191,311, 1]
    - [192,312, -1]
    - [193,313, 1]
    - [194,314, 1]
    - [195,315, -1]
    - [196,316, 1]
    - [197,317, 1]
    - [198,318, -1]
    - [199,319, 1]
    - [200,320, 1]  #'L/RForearm'
    - [201,321, 1]
    - [202,322, -1]
    - [203,323, 1]
    - [204,324, 1]
    - [205,325, -1]
    - [206,326, 1]
    - [207,327, 1]
    - [208,328, -1]
    - [209,329, 1]
    - [210,330, 1]  #'L/RWrMot2'
    - [211,331, 1]
    - [212,332, -1]
    - [213,333, 1]
    - [214,334, 1]
    - [215,335, -1]
    - [216,336, 1]
    - [217,337, 1]
    - [218,338, -1]
    - [219,339, 1]
    - [220,340, 1]  #'L/RWrMot3'
    - [221,341, 1]
    - [222,342, -1]
    - [223,343, 1]
    - [224,344, 1]
    - [225,345, -1]
    - [226,346, 1]
    - [227,347, 1]
    - [228,348, -1]
    - [229,349, 1]
    - [230,350, 1] #'L/RSoftHandLink'
    - [231,351, 1]
    - [232,352, 1]
    - [233,353, 1]
    - [234,354, 1]
    - [235,355, 1]
    - [236,356, 1]
    - [237,357, 1]
    - [238,358, 1]
    - [239,359, 1]

## other forms of OLS

# use previously known CAD parameters to identify parameter error, estimates parameters closer to
# known ones (taken from URDF file)
# for some methods, this gives parameters that are more likely to be consistent
useAPriori: 1

# identify and use direct standard with essential parameters
useEssentialParams: 0

# whether to include linear dependent columns in essential params or not
useDependents: 0

# use weighted least squares(WLS) instead of ordinary least squares
# needs small condition number, otherwise might amplify some parameters too much as the
# covariance estimation can be wrong (also assumes that error is zero mean and normal
# distributed)
useWLS: 0

# whether to filter the regressor columns (cutoff frequency is system dependent)
# possibly increases accuracy when torque ripples are present. also supposedly decreases
# correlation between (observation) regressor and measured torques
filterRegressor: 0
filterRegCutoff: 5   #frequency in Hz

## output and debugging

createPlots: 1               #create or show plots of measurements and estimated values
outputModule: 'html'         #how to output plots and other stuff ['matplotlib', 'html]
outputFilename: 'output_walkman.html'    #specify custom filename for html output
plotBaseDynamics: 0          #when using floating base, plot base forces or not
plotPerJoint: 1              #plot each joint with error in one graph

# self.options for console output
showMemUsage: 0              #print used memory for different variables
showTiming: 0                #show times various steps have taken
showRandomRegressor: 0       #show 2d plot of random regressor
showErrorHistogram: 0        #show estimation error distribution
showEssentialSteps: 0        #stop after every reduction step and show values
outputBarycentric: 0         #output all values in barycentric (e.g. urdf) form
showStandardParams: 1        #display a list of identified standard params
showBaseParams: 0            #display a list of identified base params (if appliable)
showBaseEqns: 1              #show which std params are combined for each base param
showTriangleConsistency: 0   #show per-link consistency including triangle inequality
verbose: 1                   #show more messages

# which parameters to use when estimating torques for validation. Set to one of
# ['base', 'std', 'urdf']
estimateWith: 'std'
