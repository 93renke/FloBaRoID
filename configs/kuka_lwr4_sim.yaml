
# determine number of samples to use
# (Khalil recommends about 500 times number of parameters to identify...)
start_offset: 400  #how many samples from the beginning of the (first) measurement are skipped
skip_samples: 2    #how many values to skip before using the next sample

# simulate torques from target values, don't use both
iDynSimulate: 0 # simulate torque for measured angles etc using idyntree (instead of reading data)
addNoise: 0 #0.05  #additional percentage of zero-mean white noise for simulated or measured torques

# use previously known CAD parameters to identify parameter error, estimates parameters closer to
# known ones (taken from URDF file)
# for some methods, this gives parameters that are more likely to be consistent
# (no effect for SDP constrained solutions)
useAPriori: 1

####

# whether only "good" data is being selected or simply all is used
selectBlocksFromMeasurements: 0
block_size: 250  # needs to be at least as much as parameters so regressor is square or higher

####

# constrain std params to physical consistent space to only achieve physical consistent parameters
# (currently this also does the estimation, so previously selecting another method has no effect)
# if only torque estimation is desired, not using this self.option might give a better model
# accuracy with approriate parameters
useConsistencyConstraints: 1

# constrain parameters for links more than a certain condition number to the a priori values
# (to prevent very big changes for parameters that are not expressed in the data)
noChange: 1
noChangeThresh: 200

# restrict COM to smallest enclosing box of STL Mesh (taken from <visual> in URDF)
restrictCOMtoHull: 1
# set extra scaling for mesh (e.g. if it is clear that COM will not be at outer border of
# geometry or that initial CAD data is too large)
hullScaling: 1.0

# constrain overall mass
limitOverallMass: 0
# if overall mass is set, limit to this value. If null, limit to overall a priori mass +- 30%
limitMassVal: null #16

# enforce the same upper limit for each link mass
limitMassValPerLink: null #3

# or enforce staying around the a priori masses (only set this or a combination of the other
# two mass limiting self.options to prevent constraint conflicts!)
limitMassToApriori: 1
limitMassAprioriBoundary: 1.0     #percentage of CAD value in both +- directions

# whether to take out masses to be identified because they are e.g.
# well known or introduce problems
# (essential params or when using feasability constraints)
dontIdentifyMasses: 0

####

# whether to identify and use direct standard with essential parameters
useEssentialParams: 0

# whether to include linear dependent columns in essential params or not
useDependents: 1

# use weighted least squares(WLS) instead of ordinary least squares
# needs small condition number, otherwise might amplify some parameters too much as the
# covariance estimation can be off (also assumes that error is zero mean and normal
# distributed)
useWLS: 0

# whether to filter the regressor columns (cutoff frequency is system dependent)
# mostly not improving results
filterRegressor: 0

####

# how to output plots and other stuff ['matplotlib', 'html]
outputModule: 'html'

# self.options for console output
showMemUsage: 0              #print used memory for different variables
showTiming: 0                #show times various steps have taken
showRandomRegressor: 0       #show 2d plot of random regressor
showErrorHistogram: 0        #show estimation error distribution
showEssentialSteps: 0        #stop after every reduction step and show values
outputBarycentric: 0         #output all values in barycentric (e.g. urdf) form
showStandardParams: 1        #display a list of identified standard params
showBaseParams: 1            #display a list of identified base params (if appliable)
verbose: 1                   #show more messages

# which parameters to use when estimating torques for validation. Set to one of
# ['base', 'std', 'std_direct', 'urdf
estimateWith: 'std'

# almost zero threshold for QR, SVD and other things
min_tol: 0.00001

#### excitation

# encode angles in degrees for excitation (internal and data is always rad)
useDeg: True
showOptimizationGraph: 1     #display updating graph during trajectory optimization
useGlobalOptimization: 0     #do global optimization before using local refinement. otherwise just do local from initial
