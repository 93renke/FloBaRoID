
#### excitation

excitationSimulate: 1          #simulate torques instead of using measurements (use e.g. with Gazebo)
exciteMethod: null #'ros'      #currently 'yarp', 'ros' or null
useDeg: 0                      #encode angles in degrees for excitation (internal and data is always in rad)

optimizeTrajectory: 1          #find new parameters with optimization or load previous params from file (if no file exists, use random)
showOptimizationGraph: 1       #display updating graph during trajectory optimization
showOptimizationTrajs: 1       #display the trajectory plot after each optimization step
useGlobalOptimization: 1       #do global optimization before using local refinement (does not use initial values)
globalOptIterations: 5
localOptIterations: 1          #how many optimizer iterations to use. this is not necessarily equal to function calls (~50 times of this)
maxFun: 250                    #limit objective function evaluations to this value (not used currently)
minTolConstr: 0.01           #threshold for being within constraints (only used for display)

# initial values to start optimization from (if using global opt not really important)
trajectoryPulseInit: 0.75      #determines length of one period of trajectory (smaller=longer)
trajectoryPulseMin:  0.5
trajectoryPulseMax:  1.5
trajectoryCoeffInit: 0.4       #set this as high as possible without violating constraints (see output after start)
trajectoryCoeffMin: -0.5       #determines in which range the chosen params have to be (smaller=lower vel)
trajectoryCoeffMax:  0.5
trajectoryAngleMin: -25.0      #determines the range in which the pulsation center for each joint will be (in degrees)
trajectoryAngleMax:  25.0

# instead of one range, define individual ranges for each link. If ..AngleMin/Max is to be used for
# all of them, set entry with null
trajectoryAngleRanges:
    - null

# manual angle limits: pairs of upper and lower (in degrees). put in null if values from URDF
# should be used (or leave completely empty)
ovrPosLimit:
    - null
    - [-60.0, 60.0]
    - null
    - null
    - null
    - null
    - null

# maximize minimal velocity for each joint (better excitation of parameters)
# (implemented as penalty, so will not necessarily reach the set value)
minVelocityConstraint: 0

#### identification

# fixed or floating-base dynamics
floatingBase: 0

# identify torque offsets as additional parameters
identifyTorqueOffsets: 1

# simulate torques from target values, don't use both
simulateTorques: 0 # simulate torque for measured angles etc using idyntree (instead of reading from data)
addNoise: 0 #0.05  #additional percentage of zero-mean white noise for simulated or measured torques

# almost zero threshold for QR, SVD and other things
minTol: 0.00001

## data selection

# determine number of samples to use
# (Khalil recommends about 500 times number of parameters to identify...)
startOffset: 6000    #how many samples from the beginning of each measurement file are skipped
skipSamples: 6    #how many values to skip before using the next sample

# whether only "good" data is being selected or simply all is used (selected by condition number)
selectBlocksFromMeasurements: 0
blockSize: 250  # needs to be at least as much as parameters so regressor is square or higher
selectBestPerenctage: 50   #select percentage of blocks sorted by condition number

removeNearZero: 0  #remove samples that have almost zero velocity
minVel: 0.01       #minimum mean velocity for a sample to be taken (rad/s)

# IMU processing (floating base)
waitForZeroAcc: 0   #when integrating IMU linear acceleration, wait for first time with (almost) no acceleration to start at zero velocity
zeroAccThresh: 0.4  #threshold below which acceleration is considered to be zero (m/s^2)

## use constrained SDP to solve OLS

# constrain std params to physical consistent space to only achieve physical consistent parameters
# (currently this also does the estimation, so previously selecting another method has no effect)
# if only torque estimation is desired, not using this self.option might give a better model
# accuracy with approriate parameters
useConsistencyConstraints: 1

# constrain parameters for links more than a certain condition number to the a priori values
# (to prevent very big changes for parameters that are not expressed in the data)
noChange: 1
noChangeThresh: 200

# restrict COM to smallest enclosing box of STL Mesh (taken from <visual> in URDF)
restrictCOMtoHull: 0
# set extra scaling for mesh (e.g. if it is clear that COM will not be at outer border of
# geometry or that initial CAD data is too large)
hullScaling: 1.0
# name of the directory after the package base name (as in package://basename/)
meshBaseDir: 'meshes'

# constrain overall mass
limitOverallMass: 0
# if overall mass is set, limit to this value. If null, limit to overall a priori mass +- 30%
limitMassVal: null #16

# enforce the same upper limit for each link mass
limitMassValPerLink: null #3

# or enforce staying around the a priori masses (only set this or a combination of the other
# two mass limiting self.options to prevent constraint conflicts!)
limitMassToApriori: 1
limitMassAprioriBoundary: 0.5     #percentage of CAD value in both +- directions

# whether to take out masses to be identified because they are e.g.
# well known or introduce problems
# (essential params or when using feasability constraints)
dontIdentifyMasses: 0

# specify single params that will be constrained to the CAD values
dontChangeParams: []

# define constraints for link symmetries (e.g. left and right arm),
# tuples of two parameters ids each that should be equal and 1/-1 to allow negative symmetric
symmetryConstraints:
    - [20, 90, 1]    #arm_1_1 arm_2_1
    - [21, 91, 1]
    - [22, 92, -1]
    - [23, 93, 1]
    - [24, 94, 1]
    - [25, 95, 1]
    - [26, 96, 1]
    - [27, 97, 1]
    - [28, 98, 1]
    - [29, 99, 1]
    - [30, 100, 1]   # arm1_2 arm2_2
    - [31, 101, 1]
    - [32, 102, -1]
    - [33, 103, 1]
    - [34, 104, 1]
    - [35, 105, 1]
    - [36, 106, 1]
    - [37, 107, 1]
    - [38, 108, 1]
    - [39, 109, 1]
    - [40, 110, 1]   # arm1_3 arm2_3
    - [41, 111, 1]
    - [42, 112, -1]
    - [43, 113, 1]
    - [44, 114, 1]
    - [45, 115, 1]
    - [46, 116, 1]
    - [47, 117, 1]
    - [48, 118, 1]
    - [49, 119, 1]
    - [50, 120, 1]   # arm1_4 arm2_4
    - [51, 121, 1]
    - [52, 122, -1]
    - [53, 123, 1]
    - [54, 124, 1]
    - [55, 125, 1]
    - [56, 126, 1]
    - [57, 127, 1]
    - [58, 128, 1]
    - [59, 129, 1]
    - [60, 130, 1]   # arm1_5 arm2_5
    - [61, 131, 1]
    - [62, 132, 1]
    - [63, 133, 1]
    - [64, 134, 1]
    - [65, 135, 1]
    - [66, 136, 1]
    - [67, 137, 1]
    - [68, 138, 1]
    - [69, 139, 1]
    - [70, 140, 1]   # arm1_6 arm2_6
    - [71, 141, 1]
    - [72, 142, 1]
    - [73, 143, 1]
    - [74, 144, 1]
    - [75, 145, 1]
    - [76, 146, 1]
    - [77, 147, 1]
    - [78, 148, 1]
    - [79, 149, 1]
    - [80, 150, 1]   # arm1_7 arm2_7
    - [81, 151, 1]
    - [82, 152, 1]
    - [83, 153, 1]
    - [84, 154, 1]
    - [85, 155, 1]
    - [86, 156, 1]
    - [87, 157, 1]
    - [88, 158, 1]
    - [89, 159, 1]

## other forms of OLS

# use previously known CAD parameters to identify parameter error, estimates parameters closer to
# known ones (taken from URDF file)
# for some methods, this gives parameters that are more likely to be consistent
# (don't use with constrained SDP solver)
useAPriori: 0

# identify and use direct standard with essential parameters
useEssentialParams: 0

# whether to include linear dependent columns in essential params or not
useDependents: 1

# use weighted least squares(WLS) instead of ordinary least squares
# needs small condition number, otherwise might amplify some parameters too much as the
# covariance estimation can be off (also assumes that error is zero mean and normal
# distributed)
useWLS: 0

# whether to filter the regressor columns (cutoff frequency is system dependent)
# mostly not improving results
filterRegressor: 0

## output and debugging

createPlots: 1               #create or show plots of measurements and estimated values
outputModule: 'html'         # how to output plots and other stuff ['matplotlib', 'html]
outputFilename: 'output_centauro.html'    #specify custom filename for html output
plotBaseDynamics: 0          #when using floating base, plot base forces or not
plotPerJoint: 1              #plot each joint with error in one graph

# options for console output
showMemUsage: 0              #print used memory for different variables
showTiming: 0                #show times various steps have taken
showRandomRegressor: 0       #show 2d plot of random regressor
showErrorHistogram: 0        #show estimation error distribution
showEssentialSteps: 0        #stop after every reduction step and show values
outputBarycentric: 0         #output all values in barycentric (e.g. urdf) form
showStandardParams: 1        #display a list of identified standard params
showBaseParams: 0            #display a list of identified base params (if appliable)
showTriangleConsistency: 0   #show per-link consistency including triangle inequality
verbose: 1                   #show more messages

# which parameters to use when estimating torques for validation. Set to one of
# ['base', 'std', 'std_direct', 'urdf
estimateWith: 'std'
